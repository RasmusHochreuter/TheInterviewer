---
name: interview:implement
description: "Implements a feature from a TheInterviewer specification file. Reads the spec, internalizes all requirements, prohibitions, and decision logic, then writes clean code following the reference implementation patterns. Use when user says \"implement the spec\", \"build this feature\", \"code from spec\", or after /interview has generated a spec in .claude/specs/."
argument-hint: [feature-name]
context: fork
disable-model-invocation: true
compatibility: "Requires .NET/C# project with an existing TheInterviewer specification in .claude/specs/."
metadata:
  version: 1.0.0
---

# Implement Feature from TheInterviewer Specification

You are implementing a feature from a specification generated by `/interview`. Your goal is to write clean, idiomatic code that follows the project's established patterns — as if you were a developer who simply knew the domain.

## Step 1: Find and Read the Spec

Look for the spec file based on the provided feature name:
- Check `.claude/specs/$ARGUMENTS.md`
- If not found, list `.claude/specs/` and find the closest match
- If no spec exists, tell the developer to run `/interview $ARGUMENTS` first

Read the entire spec. Internalize it. Do not proceed until you understand:
- The reference implementation and its patterns
- All prohibitions (don'ts)
- The decision tree logic
- Escalation and guardrail boundaries
- The implementation plan (files to create/modify)

## Step 2: Read the Reference Implementation

The spec names a reference implementation. Read it thoroughly:
- File structure, naming conventions, DI registration
- Validation approach, error handling, response shaping
- Test structure, naming, and assertion patterns

This is your template. Mirror its structure and style.

## Step 3: Read CLAUDE.md Conventions

Check `CLAUDE.md` for project-wide conventions and constraints that apply on top of the spec. CLAUDE.md is auto-loaded by Claude Code, but explicitly review it for architecture, tech stack, naming, and constraint sections before implementing.

## Step 4: Implement

Follow the "Files to Create / Modify" section in the spec. Work from the domain model outward:

1. **Domain model** — entities, value objects, domain events
2. **Application layer** — commands/queries, handlers, validators
3. **Infrastructure** — repositories, external service clients
4. **API layer** — endpoints, request/response DTOs
5. **Tests** — unit tests, then integration tests

## Hard Rules

**NEVER:**
- Add comments referencing the spec (`// See spec: ...`, `// REQ-001`, `// Don't #3`)
- Structure code around spec sections — structure it around clean domain logic
- Embed spec traceability IDs in code, comments, variable names, or test names
- Add comments explaining "why" when the code is self-documenting
- Create files not listed in the spec's implementation plan without asking
- Violate any prohibition listed in the spec's "Don'ts" section

**ALWAYS:**
- Write clean, idiomatic code that follows the reference implementation patterns
- Let the constraints from the spec guide your decisions silently — they should be invisible in the final code
- Name things after domain concepts, not spec concepts
- Write tests that verify behavior, named after what they verify
- Respect scope boundaries — do not implement anything listed as "Out of Scope" or "Deferred"
- Pause and ask the developer when you encounter a `[NEEDS CLARIFICATION]` marker

## When Done

Summarize what was implemented:
- Files created and modified
- Any `[NEEDS CLARIFICATION]` items you encountered and how they were resolved
- Any deviations from the spec's implementation plan (and why)
- Suggest running the test suite to verify
